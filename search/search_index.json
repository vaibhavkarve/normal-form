{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Python package for working with Conjunctive Normal Form (CNFs) and Boolean Satisfiability (SAT) This Python package is brought to you by Vaibhav Karve and Anil N. Hirani , Department of Mathematics, University of Illinois at Urbana-Champaign. normal-form recognizes variables, literals, clauses, and CNFs. The package implements an interface to easily construct CNFs and SAT-check them via third-part libraries MINISAT and PySAT . This package is written in Python v3.10, and is publicly available under the GNU-GPL-v3.0 license . It is set to be released on the Python Packaging Index as an open-source scientific package written in the literate programming style. We specifically chose to write this package as a literate program, despite the verbosity of this style, with the goal to create reproducible computational research. Installation and usage To get started on using this package, Istall Python 3.10 or higher. python3.10 -m pip install normal-form Use it in a python script (or interactive REPL) as \u2013 from normal_form import cnf from normal_form import sat # This is the CNF (a \u2228 b \u2228 \u00acc) \u2227 (\u00acb \u2228 c \u2228 \u00acd) \u2227 (\u00aca \u2228 d). x1: cnf.Cnf = cnf.cnf([[1, 2, -3], [-2, 3, -4], [-1, 4]]) sat_x1: bool = sat.cnf_bruteforce_satcheck(x1) print(sat_x1) # prints: True because x1 is satisfiable. Overview of modules The package consists of the following modules. Modules that act on Cnfs cnf.py Constructors and functions for sentences in conjunctive normal form cnf_simplify.py Functions for simplifying Cnfs, for example (a\u2228b\u2228c) \u2227 (a\u2228b\u2228\u00ac c) \u21dd (a \u2228 b) prop.py Functions for propositional calculus \u2013 conjunction, disjunction and negation Modules concerning SAT sat.py Functions for sat-checking Cnfs sxpr.py Functions for working with s-expressions Test suite tests/* Unit- and property-based tests for each module Algorithms Currently, normal-form implements the following algorithms \u2013 For formulae in conjunctive normal forms (CNFs), it implements variables, literals, clauses, Boolean formulae, and truth-assignments. It includes an API for reading, parsing and defining new instances. For satisfiability of CNFs, it contains a bruteforce algorithm, an implementation that uses the open-source sat-solver PySAT , and an implementation using the MiniSAT solver. Principles normal-form has been written in the functional-programming style with the following principles in mind \u2013 Avoid classes as much as possible. Prefer defining functions instead. Write small functions and then compose/map/filter them to create more complex functions. Use lazy evaluation strategy whenever possible (using the itertools library). Add type hints wherever possible (checked using the mypy static type-checker). Add unit-tests for each function (checked using the pytest framework). Further, add property-based testing wherever possible (using the hypothesis framework).","title":"Home"},{"location":"#installation-and-usage","text":"To get started on using this package, Istall Python 3.10 or higher. python3.10 -m pip install normal-form Use it in a python script (or interactive REPL) as \u2013 from normal_form import cnf from normal_form import sat # This is the CNF (a \u2228 b \u2228 \u00acc) \u2227 (\u00acb \u2228 c \u2228 \u00acd) \u2227 (\u00aca \u2228 d). x1: cnf.Cnf = cnf.cnf([[1, 2, -3], [-2, 3, -4], [-1, 4]]) sat_x1: bool = sat.cnf_bruteforce_satcheck(x1) print(sat_x1) # prints: True because x1 is satisfiable.","title":"Installation and usage"},{"location":"#overview-of-modules","text":"The package consists of the following modules. Modules that act on Cnfs cnf.py Constructors and functions for sentences in conjunctive normal form cnf_simplify.py Functions for simplifying Cnfs, for example (a\u2228b\u2228c) \u2227 (a\u2228b\u2228\u00ac c) \u21dd (a \u2228 b) prop.py Functions for propositional calculus \u2013 conjunction, disjunction and negation Modules concerning SAT sat.py Functions for sat-checking Cnfs sxpr.py Functions for working with s-expressions Test suite tests/* Unit- and property-based tests for each module","title":"Overview of modules"},{"location":"#algorithms","text":"Currently, normal-form implements the following algorithms \u2013 For formulae in conjunctive normal forms (CNFs), it implements variables, literals, clauses, Boolean formulae, and truth-assignments. It includes an API for reading, parsing and defining new instances. For satisfiability of CNFs, it contains a bruteforce algorithm, an implementation that uses the open-source sat-solver PySAT , and an implementation using the MiniSAT solver.","title":"Algorithms"},{"location":"#principles","text":"normal-form has been written in the functional-programming style with the following principles in mind \u2013 Avoid classes as much as possible. Prefer defining functions instead. Write small functions and then compose/map/filter them to create more complex functions. Use lazy evaluation strategy whenever possible (using the itertools library). Add type hints wherever possible (checked using the mypy static type-checker). Add unit-tests for each function (checked using the pytest framework). Further, add property-based testing wherever possible (using the hypothesis framework).","title":"Principles"},{"location":"cnf/","text":"cnf.py Constructors and functions for sentences in conjunctive normal form (Cnf). Clause Bases: frozenset [ Lit ] Clause is a subclass of frozenset[Lit] . Source code in normal_form/cnf.py 58 59 60 61 62 63 class Clause ( frozenset [ Lit ]): # pylint: disable=too-few-public-methods \"\"\"`Clause` is a subclass of `frozenset[Lit]`.\"\"\" def __repr__ ( self ) -> str : sorted_lit_values : Generator [ str , None , None ] = ( str ( lit . value ) for lit in sorted ( self )) return f \"Clause( {{ { ', ' . join ( sorted_lit_values ) } }} )\" Cnf Bases: frozenset [ Clause ] Cnf is a subclass of frozenset[Clause] . Source code in normal_form/cnf.py 66 67 68 69 70 71 72 class Cnf ( frozenset [ Clause ]): # pylint: disable=too-few-public-methods \"\"\"`Cnf` is a subclass of `frozenset[Clause]`.\"\"\" def __str__ ( self ) -> str : \"\"\"Pretty print a Cnf after sorting its sorted clause tuples.\"\"\" sorted_clause_values : Iterator [ str ] = map ( str , sorted ( self )) return f \"Cnf( {{ { ', ' . join ( sorted_clause_values ) } }} )\" __str__ () Pretty print a Cnf after sorting its sorted clause tuples. Source code in normal_form/cnf.py 69 70 71 72 def __str__ ( self ) -> str : \"\"\"Pretty print a Cnf after sorting its sorted clause tuples.\"\"\" sorted_clause_values : Iterator [ str ] = map ( str , sorted ( self )) return f \"Cnf( {{ { ', ' . join ( sorted_clause_values ) } }} )\" absolute_value ( literal ) Unnegated form of a Lit. This function is idempotent. Parameters: Name Type Description Default literal obj: Lit ): a Lit formed from a nonzero integer. required Return Check that literal is not of type Bool and then return the absolute value of literal . If it is of type Bool, then return literal as is. Source code in normal_form/cnf.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def absolute_value ( literal : Lit ) -> Lit : \"\"\"Unnegated form of a Lit. This function is idempotent. Args: literal (:obj:`Lit`): a Lit formed from a nonzero integer. Return: Check that ``literal`` is not of type Bool and then return the absolute value of ``literal``. If it is of type Bool, then return ``literal`` as is. \"\"\" if isinstance ( literal . value , Bool ): return lit ( Bool . TRUE ) return lit ( abs ( literal . value )) assign ( cnf_instance , assignment ) Assign Bool values to Variables if present in Cnf. For each Variable (key) in assignment , replace the Variable and its negation in cnf_instance using the Bool (value) in assignment . The final output is always tautologically reduced. This function is idempotent. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required assignment obj: Assignment ): a dict with keys being Variables to be replaced and values being Bools that the Variables are to be assigned to. The assignment dict need not be complete and can be partial. required Edge case An empty assignment dict results in cnf_instance simply getting tautologically reduced. Return Tautologically-reduced Cnf formed by replacing every key in the assignment dict (and those keys' negations) by corresponding Bool values. Source code in normal_form/cnf.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def assign ( cnf_instance : Cnf , assignment : Assignment ) -> Cnf : \"\"\"Assign Bool values to Variables if present in Cnf. For each Variable (key) in ``assignment``, replace the Variable and its negation in ``cnf_instance`` using the Bool (value) in ``assignment``. The final output is always tautologically reduced. This function is idempotent. Args: cnf_instance (:obj:`Cnf`) assignment (:obj:`Assignment`): a dict with keys being Variables to be replaced and values being Bools that the Variables are to be assigned to. The ``assignment`` dict need not be complete and can be partial. Edge case: An empty assignment dict results in ``cnf_instance`` simply getting tautologically reduced. Return: Tautologically-reduced Cnf formed by replacing every key in the ``assignment`` dict (and those keys' negations) by corresponding Bool values. \"\"\" for variable_instance , boolean in assignment . items (): cnf_instance = assign_variable_in_cnf ( cnf_instance , variable_instance , boolean ) return tauto_reduce ( cnf_instance ) assign_variable_in_clause ( clause_instance , variable_instance , boolean ) Assign Bool value to a Variable if present in Clause. Replace all instances of variable_instance and its negation in clause_instance with boolean and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Clause before returning results. This function is idempotent. Parameters: Name Type Description Default clause_instance obj: set[Lit] ): an abstract set (set or frozenset) of Lits. required variable_instance obj: Variable ) required boolean obj: Bool ): either TRUE or FALSE . required Return Tautologically-reduced Clause formed by assigning variable_instance to boolean in clause_instance . Source code in normal_form/cnf.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def assign_variable_in_clause ( clause_instance : Clause , variable_instance : Variable , boolean : Bool ) -> Clause : \"\"\"Assign Bool value to a Variable if present in Clause. Replace all instances of ``variable_instance`` and its negation in ``clause_instance`` with ``boolean`` and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Clause before returning results. This function is idempotent. Args: clause_instance (:obj:`set[Lit]`): an abstract set (set or frozenset) of Lits. variable_instance (:obj:`Variable`) boolean (:obj:`Bool`): either ``TRUE`` or ``FALSE``. Return: Tautologically-reduced Clause formed by assigning ``variable_instance`` to ``boolean`` in ``clause_instance``. \"\"\" assign_variable : Callable [[ Lit ], Lit ] assign_variable = ft . partial ( assign_variable_in_lit , variable_instance = variable_instance , boolean = boolean ) mapped_lits : set [ Lit ] mapped_lits = set ( map ( assign_variable , clause_instance )) return tauto_reduce ( clause ( mapped_lits )) assign_variable_in_cnf ( cnf_instance , variable_instance , boolean ) Assign Bool value to a Variable if present in Cnf. Replace all instances of variable_instance and its negation in cnf_instance with boolean and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Cnf before returning results. This function is idempotent. Parameters: Name Type Description Default cnf_instance obj: set[set[Lit]] ): an abstract set (set or frozenset) of abstract sets of Lits. required variable_instance obj: Variable ) required boolean obj: Bool ): either TRUE or FALSE . required Return Tautologically-reduced Cnf formed by assigning variable_instance to boolean in cnf_instance . Source code in normal_form/cnf.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def assign_variable_in_cnf ( cnf_instance : Cnf , variable_instance : Variable , boolean : Bool ) -> Cnf : \"\"\"Assign Bool value to a Variable if present in Cnf. Replace all instances of ``variable_instance`` and its negation in ``cnf_instance`` with ``boolean`` and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Cnf before returning results. This function is idempotent. Args: cnf_instance (:obj:`set[set[Lit]]`): an abstract set (set or frozenset) of abstract sets of Lits. variable_instance (:obj:`Variable`) boolean (:obj:`Bool`): either ``TRUE`` or ``FALSE``. Return: Tautologically-reduced Cnf formed by assigning ``variable_instance`` to ``boolean`` in ``cnf_instance``. \"\"\" assign_variable : Callable [[ Clause ], Clause ] assign_variable = ft . partial ( assign_variable_in_clause , variable_instance = variable_instance , boolean = boolean ) mapped_clauses : set [ Clause ] mapped_clauses = set ( map ( assign_variable , cnf_instance )) return tauto_reduce ( cnf ( mapped_clauses )) assign_variable_in_lit ( literal , variable_instance , boolean ) Assign Bool value to a Variable if present in Lit. Replace all instances of variable_instance and its negation with boolean and its negation respectively. Leave all else unchanged. This function is idempotent. Parameters: Name Type Description Default literal obj: Lit ) required variable_instance obj: Variable ) required boolean obj: Bool ): either TRUE or FALSE . required Return Lit formed by assigning variable_instance to boolean in literal . Source code in normal_form/cnf.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def assign_variable_in_lit ( literal : Lit , variable_instance : Variable , boolean : Bool ) -> Lit : \"\"\"Assign Bool value to a Variable if present in Lit. Replace all instances of ``variable_instance`` and its negation with ``boolean`` and its negation respectively. Leave all else unchanged. This function is idempotent. Args: literal (:obj:`Lit`) variable_instance (:obj:`Variable`) boolean (:obj:`Bool`): either ``TRUE`` or ``FALSE``. Return: Lit formed by assigning ``variable_instance`` to ``boolean`` in ``literal``. \"\"\" if literal . value == variable_instance : return lit ( boolean ) if literal . value == - variable_instance : return neg ( lit ( boolean )) return literal clause ( lit_iterable ) Constructor-function for Clause type. By definition, a Clause is a nonempty frozenset of Lits. This function is idempotent. Parameters: Name Type Description Default lit_iterable obj: Iterable[int] ): a nonempty iterable of ints, Bools, or Lits. required Return Check that each element in the iterable satisfies axioms for being a Lit and then cast to Clause. Raises: Type Description ValueError if lit_iterable is an empty iterable. Source code in normal_form/cnf.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def clause ( lit_iterable : Iterable [ int | Bool | Lit ]) -> Clause : \"\"\"Constructor-function for Clause type. By definition, a `Clause` is a nonempty frozenset of Lits. This function is idempotent. Args: lit_iterable (:obj:`Iterable[int]`): a nonempty iterable of ints, Bools, or Lits. Return: Check that each element in the iterable satisfies axioms for being a Lit and then cast to Clause. Raises: ValueError: if ``lit_iterable`` is an empty iterable. \"\"\" head , lit_iterable = mit . spy ( lit_iterable ) if not head : raise ValueError ( f \"Encountered empty input { list ( lit_iterable ) } .\" ) return Clause ( frozenset ( map ( lit , lit_iterable ))) cnf ( clause_collection ) Constructor-function for Cnf type. By definition, a Cnf is a nonempty frozenset of Clauses. This function is idempotent. Parameters: Name Type Description Default clause_collection obj: Iterable[Iterable[int]] ): a nonempty iterable (list, tuple, set, frozenset) of nonempty collections of integers or Bools. required Return Check that each element in the iterable satisfies axioms for being a Clause and then cast to Cnf. Raises: Type Description ValueError if clause_collection is an empty iterable. Source code in normal_form/cnf.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def cnf ( clause_collection : Iterable [ Iterable [ int | Bool | Lit ]]) -> Cnf : \"\"\"Constructor-function for Cnf type. By definition, a `Cnf` is a nonempty frozenset of Clauses. This function is idempotent. Args: clause_collection (:obj:`Iterable[Iterable[int]]`): a nonempty iterable (list, tuple, set, frozenset) of nonempty collections of integers or Bools. Return: Check that each element in the iterable satisfies axioms for being a Clause and then cast to Cnf. Raises: ValueError: if ``clause_collection`` is an empty iterable. \"\"\" head , clause_collection = mit . spy ( clause_collection ) if not head : raise ValueError ( f \"Encountered empty input { list ( clause_collection ) } .\" ) return Cnf ( frozenset ( map ( clause , clause_collection ))) lits ( cnf_instance ) Return frozenset of all Lits that appear in a Cnf. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return A frozenset of all lits that appear in a Cnf. Source code in normal_form/cnf.py 206 207 208 209 210 211 212 213 214 215 def lits ( cnf_instance : Cnf ) -> frozenset [ Lit ]: \"\"\"Return frozenset of all Lits that appear in a Cnf. Args: cnf_instance (:obj:`Cnf`) Return: A frozenset of all lits that appear in a Cnf. \"\"\" return frozenset . union ( * cnf_instance ) neg ( literal ) Negate a Lit. This function is an involution. Parameters: Name Type Description Default literal obj: Lit ): a Lit formed from a nonzero integer or from a Bool. required Return Return the Lit cast from the negative of literal . If literal is of type Bool, then return TRUE for FALSE , FALSE for TRUE . Source code in normal_form/cnf.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def neg ( literal : Lit ) -> Lit : \"\"\"Negate a Lit. This function is an involution. Args: literal (:obj:`Lit`): a Lit formed from a nonzero integer or from a Bool. Return: Return the Lit cast from the negative of ``literal``. If ``literal`` is of type Bool, then return ``TRUE`` for ``FALSE``, ``FALSE`` for ``TRUE``. \"\"\" match literal . value : case Bool . TRUE : return lit ( Bool . FALSE ) case Bool . FALSE : return lit ( Bool . TRUE ) case int (): return lit ( - literal . value ) case _ as unreachable : # pragma: nocover assert_never ( unreachable ) tautologically_reduce_clause ( clause_instance ) Reduce a Clause using various tautologies. The order in which these reductions are performed is important. This function is idempotent. Tautologies affecting Clauses (\u22a4 \u2228 c = \u22a4) (\u22a5 = \u22a5) (\u22a5 \u2228 c = c) (c \u2228 \u00acc = \u22a4), where x is a Clause, \u22a4 represents TRUE , \u22a5 represents FALSE , and \u2228 is disjunction. Parameters: Name Type Description Default clause_instance obj: set[Lit] ): an abstract set (a set or a frozenset) of Lits. required Return The Clause formed by performing all the above-mentioned tautological reductions. Source code in normal_form/cnf.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def tautologically_reduce_clause ( clause_instance : Clause ) -> Clause : r \"\"\"Reduce a Clause using various tautologies. The order in which these reductions are performed is important. This function is idempotent. Tautologies affecting Clauses: (\u22a4 \u2228 c = \u22a4) (\u22a5 = \u22a5) (\u22a5 \u2228 c = c) (c \u2228 \u00acc = \u22a4), where `x` is a Clause, `\u22a4` represents ``TRUE``, `\u22a5` represents ``FALSE``, and `\u2228` is disjunction. Args: clause_instance (:obj:`set[Lit]`): an abstract set (a set or a frozenset) of Lits. Return: The Clause formed by performing all the above-mentioned tautological reductions. \"\"\" if lit ( Bool . TRUE ) in clause_instance : return TRUE_CLAUSE if set ( clause_instance ) == { lit ( Bool . FALSE )}: return FALSE_CLAUSE if lit ( Bool . FALSE ) in clause_instance : clause_instance = clause ( [ literal for literal in clause_instance if literal != lit ( Bool . FALSE )]) if not set ( map ( neg , clause_instance )) . isdisjoint ( clause_instance ): return TRUE_CLAUSE return clause ( clause_instance ) tautologically_reduce_cnf ( cnf_instance ) Reduce a Cnf using various tautologies. The order in which these reductions are performed is important. This function is idempotent. This is a recursive function that is guaranteed to terminate. Tautologies affecting Cnfs (x \u2227 \u22a5 = \u22a5) (\u22a4 = \u22a4) (\u22a4 \u2227 x = x), where x is a Cnf, \u22a4 represents TRUE , \u22a5 represents FALSE , and \u2227 is conjunction. There is also a special reduction for Cnfs (x \u2227 y = x IF x < y), where x is a Cnf, y is another Cnf, and x < y means that every clause of x is also present as a clause in y . Parameters: Name Type Description Default cnf_instance obj: set[set[Lit]] ): an abstract set (set or frozenset) of abstract sets required Return The Cnf formed by first reducing all the clauses tautologically and then performing all the above-mentioned tautological reductions on the Cnf itself. Source code in normal_form/cnf.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def tautologically_reduce_cnf ( cnf_instance : Cnf ) -> Cnf : r \"\"\"Reduce a Cnf using various tautologies. The order in which these reductions are performed is important. This function is idempotent. This is a recursive function that is guaranteed to terminate. Tautologies affecting Cnfs: (x \u2227 \u22a5 = \u22a5) (\u22a4 = \u22a4) (\u22a4 \u2227 x = x), where `x` is a Cnf, `\u22a4` represents ``TRUE``, `\u22a5` represents ``FALSE``, and `\u2227` is conjunction. There is also a special reduction for Cnfs: (x \u2227 y = x IF x < y), where `x` is a Cnf, `y` is another Cnf, and `x < y` means that every clause of `x` is also present as a clause in `y`. Args: cnf_instance (:obj:`set[set[Lit]]`): an abstract set (set or frozenset) of abstract sets of Lits. Return: The Cnf formed by first reducing all the clauses tautologically and then performing all the above-mentioned tautological reductions on the Cnf itself. \"\"\" clause_set_reduced : set [ Clause ] clause_set_reduced = set ( map ( tautologically_reduce_clause , cnf_instance )) if FALSE_CLAUSE in clause_set_reduced : return FALSE_CNF if clause_set_reduced == set ( TRUE_CNF ): return TRUE_CNF if TRUE_CLAUSE in clause_set_reduced : return tautologically_reduce_cnf ( cnf ( clause_set_reduced - TRUE_CNF )) # Special reduction. x for clause1 , clause2 in it . permutations ( clause_set_reduced , 2 ): if clause1 < clause2 : return tautologically_reduce_cnf ( cnf ( clause_set_reduced - { clause2 })) return cnf ( clause_set_reduced ) variable ( positive_int ) Constructor-function for Variable type. By definition, a Variable is just a positive integer. This function is idempotent. Parameters: Name Type Description Default positive_int obj: int ): required Return If input is indeed positive, then return positive_int after casting to Variable. Raises: Type Description ValueError if positive_int <= 0 . Source code in normal_form/cnf.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def variable ( positive_int : int | Variable ) -> Variable : \"\"\"Constructor-function for Variable type. By definition, a `Variable` is just a positive integer. This function is idempotent. Args: positive_int (:obj:`int`): Return: If input is indeed positive, then return ``positive_int`` after casting to Variable. Raises: ValueError: if ``positive_int <= 0``. \"\"\" if positive_int <= 0 : raise ValueError ( \"Variable must be a positive integer.\" ) return Variable ( positive_int )","title":"cnf.py"},{"location":"cnf/#cnfpy","text":"Constructors and functions for sentences in conjunctive normal form (Cnf).","title":"cnf.py"},{"location":"cnf/#normal_form.cnf.Clause","text":"Bases: frozenset [ Lit ] Clause is a subclass of frozenset[Lit] . Source code in normal_form/cnf.py 58 59 60 61 62 63 class Clause ( frozenset [ Lit ]): # pylint: disable=too-few-public-methods \"\"\"`Clause` is a subclass of `frozenset[Lit]`.\"\"\" def __repr__ ( self ) -> str : sorted_lit_values : Generator [ str , None , None ] = ( str ( lit . value ) for lit in sorted ( self )) return f \"Clause( {{ { ', ' . join ( sorted_lit_values ) } }} )\"","title":"Clause"},{"location":"cnf/#normal_form.cnf.Cnf","text":"Bases: frozenset [ Clause ] Cnf is a subclass of frozenset[Clause] . Source code in normal_form/cnf.py 66 67 68 69 70 71 72 class Cnf ( frozenset [ Clause ]): # pylint: disable=too-few-public-methods \"\"\"`Cnf` is a subclass of `frozenset[Clause]`.\"\"\" def __str__ ( self ) -> str : \"\"\"Pretty print a Cnf after sorting its sorted clause tuples.\"\"\" sorted_clause_values : Iterator [ str ] = map ( str , sorted ( self )) return f \"Cnf( {{ { ', ' . join ( sorted_clause_values ) } }} )\"","title":"Cnf"},{"location":"cnf/#normal_form.cnf.Cnf.__str__","text":"Pretty print a Cnf after sorting its sorted clause tuples. Source code in normal_form/cnf.py 69 70 71 72 def __str__ ( self ) -> str : \"\"\"Pretty print a Cnf after sorting its sorted clause tuples.\"\"\" sorted_clause_values : Iterator [ str ] = map ( str , sorted ( self )) return f \"Cnf( {{ { ', ' . join ( sorted_clause_values ) } }} )\"","title":"__str__()"},{"location":"cnf/#normal_form.cnf.absolute_value","text":"Unnegated form of a Lit. This function is idempotent. Parameters: Name Type Description Default literal obj: Lit ): a Lit formed from a nonzero integer. required Return Check that literal is not of type Bool and then return the absolute value of literal . If it is of type Bool, then return literal as is. Source code in normal_form/cnf.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def absolute_value ( literal : Lit ) -> Lit : \"\"\"Unnegated form of a Lit. This function is idempotent. Args: literal (:obj:`Lit`): a Lit formed from a nonzero integer. Return: Check that ``literal`` is not of type Bool and then return the absolute value of ``literal``. If it is of type Bool, then return ``literal`` as is. \"\"\" if isinstance ( literal . value , Bool ): return lit ( Bool . TRUE ) return lit ( abs ( literal . value ))","title":"absolute_value()"},{"location":"cnf/#normal_form.cnf.assign","text":"Assign Bool values to Variables if present in Cnf. For each Variable (key) in assignment , replace the Variable and its negation in cnf_instance using the Bool (value) in assignment . The final output is always tautologically reduced. This function is idempotent. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required assignment obj: Assignment ): a dict with keys being Variables to be replaced and values being Bools that the Variables are to be assigned to. The assignment dict need not be complete and can be partial. required Edge case An empty assignment dict results in cnf_instance simply getting tautologically reduced. Return Tautologically-reduced Cnf formed by replacing every key in the assignment dict (and those keys' negations) by corresponding Bool values. Source code in normal_form/cnf.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def assign ( cnf_instance : Cnf , assignment : Assignment ) -> Cnf : \"\"\"Assign Bool values to Variables if present in Cnf. For each Variable (key) in ``assignment``, replace the Variable and its negation in ``cnf_instance`` using the Bool (value) in ``assignment``. The final output is always tautologically reduced. This function is idempotent. Args: cnf_instance (:obj:`Cnf`) assignment (:obj:`Assignment`): a dict with keys being Variables to be replaced and values being Bools that the Variables are to be assigned to. The ``assignment`` dict need not be complete and can be partial. Edge case: An empty assignment dict results in ``cnf_instance`` simply getting tautologically reduced. Return: Tautologically-reduced Cnf formed by replacing every key in the ``assignment`` dict (and those keys' negations) by corresponding Bool values. \"\"\" for variable_instance , boolean in assignment . items (): cnf_instance = assign_variable_in_cnf ( cnf_instance , variable_instance , boolean ) return tauto_reduce ( cnf_instance )","title":"assign()"},{"location":"cnf/#normal_form.cnf.assign_variable_in_clause","text":"Assign Bool value to a Variable if present in Clause. Replace all instances of variable_instance and its negation in clause_instance with boolean and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Clause before returning results. This function is idempotent. Parameters: Name Type Description Default clause_instance obj: set[Lit] ): an abstract set (set or frozenset) of Lits. required variable_instance obj: Variable ) required boolean obj: Bool ): either TRUE or FALSE . required Return Tautologically-reduced Clause formed by assigning variable_instance to boolean in clause_instance . Source code in normal_form/cnf.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def assign_variable_in_clause ( clause_instance : Clause , variable_instance : Variable , boolean : Bool ) -> Clause : \"\"\"Assign Bool value to a Variable if present in Clause. Replace all instances of ``variable_instance`` and its negation in ``clause_instance`` with ``boolean`` and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Clause before returning results. This function is idempotent. Args: clause_instance (:obj:`set[Lit]`): an abstract set (set or frozenset) of Lits. variable_instance (:obj:`Variable`) boolean (:obj:`Bool`): either ``TRUE`` or ``FALSE``. Return: Tautologically-reduced Clause formed by assigning ``variable_instance`` to ``boolean`` in ``clause_instance``. \"\"\" assign_variable : Callable [[ Lit ], Lit ] assign_variable = ft . partial ( assign_variable_in_lit , variable_instance = variable_instance , boolean = boolean ) mapped_lits : set [ Lit ] mapped_lits = set ( map ( assign_variable , clause_instance )) return tauto_reduce ( clause ( mapped_lits ))","title":"assign_variable_in_clause()"},{"location":"cnf/#normal_form.cnf.assign_variable_in_cnf","text":"Assign Bool value to a Variable if present in Cnf. Replace all instances of variable_instance and its negation in cnf_instance with boolean and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Cnf before returning results. This function is idempotent. Parameters: Name Type Description Default cnf_instance obj: set[set[Lit]] ): an abstract set (set or frozenset) of abstract sets of Lits. required variable_instance obj: Variable ) required boolean obj: Bool ): either TRUE or FALSE . required Return Tautologically-reduced Cnf formed by assigning variable_instance to boolean in cnf_instance . Source code in normal_form/cnf.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def assign_variable_in_cnf ( cnf_instance : Cnf , variable_instance : Variable , boolean : Bool ) -> Cnf : \"\"\"Assign Bool value to a Variable if present in Cnf. Replace all instances of ``variable_instance`` and its negation in ``cnf_instance`` with ``boolean`` and its negation respectively. Leave all else unchanged. Perform tautological reductions on the Cnf before returning results. This function is idempotent. Args: cnf_instance (:obj:`set[set[Lit]]`): an abstract set (set or frozenset) of abstract sets of Lits. variable_instance (:obj:`Variable`) boolean (:obj:`Bool`): either ``TRUE`` or ``FALSE``. Return: Tautologically-reduced Cnf formed by assigning ``variable_instance`` to ``boolean`` in ``cnf_instance``. \"\"\" assign_variable : Callable [[ Clause ], Clause ] assign_variable = ft . partial ( assign_variable_in_clause , variable_instance = variable_instance , boolean = boolean ) mapped_clauses : set [ Clause ] mapped_clauses = set ( map ( assign_variable , cnf_instance )) return tauto_reduce ( cnf ( mapped_clauses ))","title":"assign_variable_in_cnf()"},{"location":"cnf/#normal_form.cnf.assign_variable_in_lit","text":"Assign Bool value to a Variable if present in Lit. Replace all instances of variable_instance and its negation with boolean and its negation respectively. Leave all else unchanged. This function is idempotent. Parameters: Name Type Description Default literal obj: Lit ) required variable_instance obj: Variable ) required boolean obj: Bool ): either TRUE or FALSE . required Return Lit formed by assigning variable_instance to boolean in literal . Source code in normal_form/cnf.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def assign_variable_in_lit ( literal : Lit , variable_instance : Variable , boolean : Bool ) -> Lit : \"\"\"Assign Bool value to a Variable if present in Lit. Replace all instances of ``variable_instance`` and its negation with ``boolean`` and its negation respectively. Leave all else unchanged. This function is idempotent. Args: literal (:obj:`Lit`) variable_instance (:obj:`Variable`) boolean (:obj:`Bool`): either ``TRUE`` or ``FALSE``. Return: Lit formed by assigning ``variable_instance`` to ``boolean`` in ``literal``. \"\"\" if literal . value == variable_instance : return lit ( boolean ) if literal . value == - variable_instance : return neg ( lit ( boolean )) return literal","title":"assign_variable_in_lit()"},{"location":"cnf/#normal_form.cnf.clause","text":"Constructor-function for Clause type. By definition, a Clause is a nonempty frozenset of Lits. This function is idempotent. Parameters: Name Type Description Default lit_iterable obj: Iterable[int] ): a nonempty iterable of ints, Bools, or Lits. required Return Check that each element in the iterable satisfies axioms for being a Lit and then cast to Clause. Raises: Type Description ValueError if lit_iterable is an empty iterable. Source code in normal_form/cnf.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def clause ( lit_iterable : Iterable [ int | Bool | Lit ]) -> Clause : \"\"\"Constructor-function for Clause type. By definition, a `Clause` is a nonempty frozenset of Lits. This function is idempotent. Args: lit_iterable (:obj:`Iterable[int]`): a nonempty iterable of ints, Bools, or Lits. Return: Check that each element in the iterable satisfies axioms for being a Lit and then cast to Clause. Raises: ValueError: if ``lit_iterable`` is an empty iterable. \"\"\" head , lit_iterable = mit . spy ( lit_iterable ) if not head : raise ValueError ( f \"Encountered empty input { list ( lit_iterable ) } .\" ) return Clause ( frozenset ( map ( lit , lit_iterable )))","title":"clause()"},{"location":"cnf/#normal_form.cnf.cnf","text":"Constructor-function for Cnf type. By definition, a Cnf is a nonempty frozenset of Clauses. This function is idempotent. Parameters: Name Type Description Default clause_collection obj: Iterable[Iterable[int]] ): a nonempty iterable (list, tuple, set, frozenset) of nonempty collections of integers or Bools. required Return Check that each element in the iterable satisfies axioms for being a Clause and then cast to Cnf. Raises: Type Description ValueError if clause_collection is an empty iterable. Source code in normal_form/cnf.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def cnf ( clause_collection : Iterable [ Iterable [ int | Bool | Lit ]]) -> Cnf : \"\"\"Constructor-function for Cnf type. By definition, a `Cnf` is a nonempty frozenset of Clauses. This function is idempotent. Args: clause_collection (:obj:`Iterable[Iterable[int]]`): a nonempty iterable (list, tuple, set, frozenset) of nonempty collections of integers or Bools. Return: Check that each element in the iterable satisfies axioms for being a Clause and then cast to Cnf. Raises: ValueError: if ``clause_collection`` is an empty iterable. \"\"\" head , clause_collection = mit . spy ( clause_collection ) if not head : raise ValueError ( f \"Encountered empty input { list ( clause_collection ) } .\" ) return Cnf ( frozenset ( map ( clause , clause_collection )))","title":"cnf()"},{"location":"cnf/#normal_form.cnf.lits","text":"Return frozenset of all Lits that appear in a Cnf. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return A frozenset of all lits that appear in a Cnf. Source code in normal_form/cnf.py 206 207 208 209 210 211 212 213 214 215 def lits ( cnf_instance : Cnf ) -> frozenset [ Lit ]: \"\"\"Return frozenset of all Lits that appear in a Cnf. Args: cnf_instance (:obj:`Cnf`) Return: A frozenset of all lits that appear in a Cnf. \"\"\" return frozenset . union ( * cnf_instance )","title":"lits()"},{"location":"cnf/#normal_form.cnf.neg","text":"Negate a Lit. This function is an involution. Parameters: Name Type Description Default literal obj: Lit ): a Lit formed from a nonzero integer or from a Bool. required Return Return the Lit cast from the negative of literal . If literal is of type Bool, then return TRUE for FALSE , FALSE for TRUE . Source code in normal_form/cnf.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def neg ( literal : Lit ) -> Lit : \"\"\"Negate a Lit. This function is an involution. Args: literal (:obj:`Lit`): a Lit formed from a nonzero integer or from a Bool. Return: Return the Lit cast from the negative of ``literal``. If ``literal`` is of type Bool, then return ``TRUE`` for ``FALSE``, ``FALSE`` for ``TRUE``. \"\"\" match literal . value : case Bool . TRUE : return lit ( Bool . FALSE ) case Bool . FALSE : return lit ( Bool . TRUE ) case int (): return lit ( - literal . value ) case _ as unreachable : # pragma: nocover assert_never ( unreachable )","title":"neg()"},{"location":"cnf/#normal_form.cnf.tautologically_reduce_clause","text":"Reduce a Clause using various tautologies. The order in which these reductions are performed is important. This function is idempotent. Tautologies affecting Clauses (\u22a4 \u2228 c = \u22a4) (\u22a5 = \u22a5) (\u22a5 \u2228 c = c) (c \u2228 \u00acc = \u22a4), where x is a Clause, \u22a4 represents TRUE , \u22a5 represents FALSE , and \u2228 is disjunction. Parameters: Name Type Description Default clause_instance obj: set[Lit] ): an abstract set (a set or a frozenset) of Lits. required Return The Clause formed by performing all the above-mentioned tautological reductions. Source code in normal_form/cnf.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def tautologically_reduce_clause ( clause_instance : Clause ) -> Clause : r \"\"\"Reduce a Clause using various tautologies. The order in which these reductions are performed is important. This function is idempotent. Tautologies affecting Clauses: (\u22a4 \u2228 c = \u22a4) (\u22a5 = \u22a5) (\u22a5 \u2228 c = c) (c \u2228 \u00acc = \u22a4), where `x` is a Clause, `\u22a4` represents ``TRUE``, `\u22a5` represents ``FALSE``, and `\u2228` is disjunction. Args: clause_instance (:obj:`set[Lit]`): an abstract set (a set or a frozenset) of Lits. Return: The Clause formed by performing all the above-mentioned tautological reductions. \"\"\" if lit ( Bool . TRUE ) in clause_instance : return TRUE_CLAUSE if set ( clause_instance ) == { lit ( Bool . FALSE )}: return FALSE_CLAUSE if lit ( Bool . FALSE ) in clause_instance : clause_instance = clause ( [ literal for literal in clause_instance if literal != lit ( Bool . FALSE )]) if not set ( map ( neg , clause_instance )) . isdisjoint ( clause_instance ): return TRUE_CLAUSE return clause ( clause_instance )","title":"tautologically_reduce_clause()"},{"location":"cnf/#normal_form.cnf.tautologically_reduce_cnf","text":"Reduce a Cnf using various tautologies. The order in which these reductions are performed is important. This function is idempotent. This is a recursive function that is guaranteed to terminate. Tautologies affecting Cnfs (x \u2227 \u22a5 = \u22a5) (\u22a4 = \u22a4) (\u22a4 \u2227 x = x), where x is a Cnf, \u22a4 represents TRUE , \u22a5 represents FALSE , and \u2227 is conjunction. There is also a special reduction for Cnfs (x \u2227 y = x IF x < y), where x is a Cnf, y is another Cnf, and x < y means that every clause of x is also present as a clause in y . Parameters: Name Type Description Default cnf_instance obj: set[set[Lit]] ): an abstract set (set or frozenset) of abstract sets required Return The Cnf formed by first reducing all the clauses tautologically and then performing all the above-mentioned tautological reductions on the Cnf itself. Source code in normal_form/cnf.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def tautologically_reduce_cnf ( cnf_instance : Cnf ) -> Cnf : r \"\"\"Reduce a Cnf using various tautologies. The order in which these reductions are performed is important. This function is idempotent. This is a recursive function that is guaranteed to terminate. Tautologies affecting Cnfs: (x \u2227 \u22a5 = \u22a5) (\u22a4 = \u22a4) (\u22a4 \u2227 x = x), where `x` is a Cnf, `\u22a4` represents ``TRUE``, `\u22a5` represents ``FALSE``, and `\u2227` is conjunction. There is also a special reduction for Cnfs: (x \u2227 y = x IF x < y), where `x` is a Cnf, `y` is another Cnf, and `x < y` means that every clause of `x` is also present as a clause in `y`. Args: cnf_instance (:obj:`set[set[Lit]]`): an abstract set (set or frozenset) of abstract sets of Lits. Return: The Cnf formed by first reducing all the clauses tautologically and then performing all the above-mentioned tautological reductions on the Cnf itself. \"\"\" clause_set_reduced : set [ Clause ] clause_set_reduced = set ( map ( tautologically_reduce_clause , cnf_instance )) if FALSE_CLAUSE in clause_set_reduced : return FALSE_CNF if clause_set_reduced == set ( TRUE_CNF ): return TRUE_CNF if TRUE_CLAUSE in clause_set_reduced : return tautologically_reduce_cnf ( cnf ( clause_set_reduced - TRUE_CNF )) # Special reduction. x for clause1 , clause2 in it . permutations ( clause_set_reduced , 2 ): if clause1 < clause2 : return tautologically_reduce_cnf ( cnf ( clause_set_reduced - { clause2 })) return cnf ( clause_set_reduced )","title":"tautologically_reduce_cnf()"},{"location":"cnf/#normal_form.cnf.variable","text":"Constructor-function for Variable type. By definition, a Variable is just a positive integer. This function is idempotent. Parameters: Name Type Description Default positive_int obj: int ): required Return If input is indeed positive, then return positive_int after casting to Variable. Raises: Type Description ValueError if positive_int <= 0 . Source code in normal_form/cnf.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def variable ( positive_int : int | Variable ) -> Variable : \"\"\"Constructor-function for Variable type. By definition, a `Variable` is just a positive integer. This function is idempotent. Args: positive_int (:obj:`int`): Return: If input is indeed positive, then return ``positive_int`` after casting to Variable. Raises: ValueError: if ``positive_int <= 0``. \"\"\" if positive_int <= 0 : raise ValueError ( \"Variable must be a positive integer.\" ) return Variable ( positive_int )","title":"variable()"},{"location":"cnf_simplify/","text":"cnf_simplify.py Functions for simplifying Cnfs, particularly (a\u2228b\u2228c) \u2227 (a\u2228b\u2228\u00acc) to (a\u2228b). This simplification is traditionally handled by the Quine\u2013McCluskey algorithm. But for our simple use-case, this might be over-engineered. Instead we implement our own functions for making this simplification. absolute_literals_of_clause ( clause ) Return the set of all absolute-values of all literals in a clause, . absolute_literals_of_clause = set \u2218 map(cnf.absolute_value, __) Source code in normal_form/cnf_simplify.py 15 16 17 18 19 20 21 def absolute_literals_of_clause ( clause : cnf . Clause ) -> set [ cnf . Lit ]: \"\"\"Return the set of all absolute-values of all literals in a clause, . absolute_literals_of_clause = set \u2218 map(cnf.absolute_value, __) \"\"\" return { cnf . absolute_value ( literal ) for literal in clause } differing_lits ( clause1 , clause2 ) Give a set of literals that two clauses differ on. This returns a set that can give us twice the Hamming distance between clauses. Assume that the clauses have the same image under hedge_of_clause . If not, raise an AssertionError. Quick way to compute set of distinct lits is to calculate the symmetric difference between them (using the ^ operator). \u2200 c : cnf.Clause, differing_lits(c, c) = \u2205 \u2200 c d : cnf.Clause, differing_lits(c, d) = differing_lits(d, c) Source code in normal_form/cnf_simplify.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def differing_lits ( clause1 : cnf . Clause , clause2 : cnf . Clause ) -> frozenset [ cnf . Lit ]: \"\"\"Give a set of literals that two clauses differ on. This returns a set that can give us twice the Hamming distance between clauses. Assume that the clauses have the same image under `hedge_of_clause`. If not, raise an AssertionError. Quick way to compute set of distinct lits is to calculate the symmetric difference between them (using the ^ operator). \u2200 c : cnf.Clause, differing_lits(c, c) = \u2205 \u2200 c d : cnf.Clause, differing_lits(c, d) = differing_lits(d, c) \"\"\" return clause1 ^ clause2 equivalent_smaller_clause ( clause1 , clause2 ) Given clauses that are distance 1 apart, return smaller equiv. clause. The smaller equivalent clause is given by the intersection of the two clauses. This is computed using the & operator. Source code in normal_form/cnf_simplify.py 43 44 45 46 47 48 49 50 51 52 53 54 def equivalent_smaller_clause ( clause1 : cnf . Clause , clause2 : cnf . Clause ) -> cnf . Clause : \"\"\"Given clauses that are distance 1 apart, return smaller equiv. clause. The smaller equivalent clause is given by the intersection of the two clauses. This is computed using the `&` operator. \"\"\" assert len ( differing_lits ( clause1 , clause2 )) == 2 , 'Hamming distance should be 1.' equiv_clause : cnf . Clause = cnf . clause ( clause1 & clause2 ) assert len ( equiv_clause ) == len ( clause1 ) - 1 return equiv_clause reduce_cnf ( cnf_instance ) Reduce distance=1 as well as subclauses. Source code in normal_form/cnf_simplify.py 92 93 94 def reduce_cnf ( cnf_instance : cnf . Cnf ) -> cnf . Cnf : \"\"\"Reduce distance=1 as well as subclauses.\"\"\" return subclause_reduction ( reduce_distance_one_clauses ( cnf_instance )) reduce_distance_one_clauses ( cnf_instance ) Reduce all clauses in the the The problem this function is trying to solve is known to be NP-hard. This is an inefficient solution to this problem. Do not apply it to Cnfs with more than 5 variables. reduce_cnf = ungroup_clauses_to_cnf \u2218 reduce_all_groups \u2218 group_clauses_by_edge Source code in normal_form/cnf_simplify.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def reduce_distance_one_clauses ( cnf_instance : cnf . Cnf ) -> cnf . Cnf : \"\"\"Reduce all clauses in the the The problem this function is trying to solve is known to be NP-hard. This is an inefficient solution to this problem. Do not apply it to Cnfs with more than 5 variables. reduce_cnf = ungroup_clauses_to_cnf \u2218 reduce_all_groups \u2218 group_clauses_by_edge \"\"\" for clause1 , clause2 in it . combinations ( cnf_instance , 2 ): var_set1 : set [ cnf . Lit ] = absolute_literals_of_clause ( clause1 ) var_set2 : set [ cnf . Lit ] = absolute_literals_of_clause ( clause2 ) if var_set1 == var_set2 and len ( differing_lits ( clause1 , clause2 )) == 2 : # Hamming distance in clauses = 1 reduced_cnf = cnf_instance - { clause1 , clause2 } reduced_cnf = reduced_cnf | { equivalent_smaller_clause ( clause1 , clause2 )} return reduce_distance_one_clauses ( cnf . cnf ( reduced_cnf )) return cnf_instance subclause_reduction ( cnf_instance ) Replace the conjunction of two clauses with the smaller clause. If c\u2081 c\u2082 : cnf.Clause, we sat the c\u2081 \u226a c\u2082 if every literal of c\u2081 is in c\u2082. Replace c\u2081 \u2227 c\u2082 with c\u2081 whenever c\u2081 \u226a c\u2082. Perform action recursively. Source code in normal_form/cnf_simplify.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def subclause_reduction ( cnf_instance : cnf . Cnf ) -> cnf . Cnf : \"\"\"Replace the conjunction of two clauses with the smaller clause. If c\u2081 c\u2082 : cnf.Clause, we sat the c\u2081 \u226a c\u2082 if every literal of c\u2081 is in c\u2082. Replace c\u2081 \u2227 c\u2082 with c\u2081 whenever c\u2081 \u226a c\u2082. Perform action recursively. \"\"\" for clause1 , clause2 in it . permutations ( cnf_instance , 2 ): if clause1 <= clause2 : new_cnf : cnf . Cnf = cnf . cnf ( cnf_instance - { clause2 }) return subclause_reduction ( new_cnf ) return cnf_instance","title":"cnf_simplify.py"},{"location":"cnf_simplify/#cnf_simplifypy","text":"Functions for simplifying Cnfs, particularly (a\u2228b\u2228c) \u2227 (a\u2228b\u2228\u00acc) to (a\u2228b). This simplification is traditionally handled by the Quine\u2013McCluskey algorithm. But for our simple use-case, this might be over-engineered. Instead we implement our own functions for making this simplification.","title":"cnf_simplify.py"},{"location":"cnf_simplify/#normal_form.cnf_simplify.absolute_literals_of_clause","text":"Return the set of all absolute-values of all literals in a clause, . absolute_literals_of_clause = set \u2218 map(cnf.absolute_value, __) Source code in normal_form/cnf_simplify.py 15 16 17 18 19 20 21 def absolute_literals_of_clause ( clause : cnf . Clause ) -> set [ cnf . Lit ]: \"\"\"Return the set of all absolute-values of all literals in a clause, . absolute_literals_of_clause = set \u2218 map(cnf.absolute_value, __) \"\"\" return { cnf . absolute_value ( literal ) for literal in clause }","title":"absolute_literals_of_clause()"},{"location":"cnf_simplify/#normal_form.cnf_simplify.differing_lits","text":"Give a set of literals that two clauses differ on. This returns a set that can give us twice the Hamming distance between clauses. Assume that the clauses have the same image under hedge_of_clause . If not, raise an AssertionError. Quick way to compute set of distinct lits is to calculate the symmetric difference between them (using the ^ operator). \u2200 c : cnf.Clause, differing_lits(c, c) = \u2205 \u2200 c d : cnf.Clause, differing_lits(c, d) = differing_lits(d, c) Source code in normal_form/cnf_simplify.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def differing_lits ( clause1 : cnf . Clause , clause2 : cnf . Clause ) -> frozenset [ cnf . Lit ]: \"\"\"Give a set of literals that two clauses differ on. This returns a set that can give us twice the Hamming distance between clauses. Assume that the clauses have the same image under `hedge_of_clause`. If not, raise an AssertionError. Quick way to compute set of distinct lits is to calculate the symmetric difference between them (using the ^ operator). \u2200 c : cnf.Clause, differing_lits(c, c) = \u2205 \u2200 c d : cnf.Clause, differing_lits(c, d) = differing_lits(d, c) \"\"\" return clause1 ^ clause2","title":"differing_lits()"},{"location":"cnf_simplify/#normal_form.cnf_simplify.equivalent_smaller_clause","text":"Given clauses that are distance 1 apart, return smaller equiv. clause. The smaller equivalent clause is given by the intersection of the two clauses. This is computed using the & operator. Source code in normal_form/cnf_simplify.py 43 44 45 46 47 48 49 50 51 52 53 54 def equivalent_smaller_clause ( clause1 : cnf . Clause , clause2 : cnf . Clause ) -> cnf . Clause : \"\"\"Given clauses that are distance 1 apart, return smaller equiv. clause. The smaller equivalent clause is given by the intersection of the two clauses. This is computed using the `&` operator. \"\"\" assert len ( differing_lits ( clause1 , clause2 )) == 2 , 'Hamming distance should be 1.' equiv_clause : cnf . Clause = cnf . clause ( clause1 & clause2 ) assert len ( equiv_clause ) == len ( clause1 ) - 1 return equiv_clause","title":"equivalent_smaller_clause()"},{"location":"cnf_simplify/#normal_form.cnf_simplify.reduce_cnf","text":"Reduce distance=1 as well as subclauses. Source code in normal_form/cnf_simplify.py 92 93 94 def reduce_cnf ( cnf_instance : cnf . Cnf ) -> cnf . Cnf : \"\"\"Reduce distance=1 as well as subclauses.\"\"\" return subclause_reduction ( reduce_distance_one_clauses ( cnf_instance ))","title":"reduce_cnf()"},{"location":"cnf_simplify/#normal_form.cnf_simplify.reduce_distance_one_clauses","text":"Reduce all clauses in the the The problem this function is trying to solve is known to be NP-hard. This is an inefficient solution to this problem. Do not apply it to Cnfs with more than 5 variables. reduce_cnf = ungroup_clauses_to_cnf \u2218 reduce_all_groups \u2218 group_clauses_by_edge Source code in normal_form/cnf_simplify.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def reduce_distance_one_clauses ( cnf_instance : cnf . Cnf ) -> cnf . Cnf : \"\"\"Reduce all clauses in the the The problem this function is trying to solve is known to be NP-hard. This is an inefficient solution to this problem. Do not apply it to Cnfs with more than 5 variables. reduce_cnf = ungroup_clauses_to_cnf \u2218 reduce_all_groups \u2218 group_clauses_by_edge \"\"\" for clause1 , clause2 in it . combinations ( cnf_instance , 2 ): var_set1 : set [ cnf . Lit ] = absolute_literals_of_clause ( clause1 ) var_set2 : set [ cnf . Lit ] = absolute_literals_of_clause ( clause2 ) if var_set1 == var_set2 and len ( differing_lits ( clause1 , clause2 )) == 2 : # Hamming distance in clauses = 1 reduced_cnf = cnf_instance - { clause1 , clause2 } reduced_cnf = reduced_cnf | { equivalent_smaller_clause ( clause1 , clause2 )} return reduce_distance_one_clauses ( cnf . cnf ( reduced_cnf )) return cnf_instance","title":"reduce_distance_one_clauses()"},{"location":"cnf_simplify/#normal_form.cnf_simplify.subclause_reduction","text":"Replace the conjunction of two clauses with the smaller clause. If c\u2081 c\u2082 : cnf.Clause, we sat the c\u2081 \u226a c\u2082 if every literal of c\u2081 is in c\u2082. Replace c\u2081 \u2227 c\u2082 with c\u2081 whenever c\u2081 \u226a c\u2082. Perform action recursively. Source code in normal_form/cnf_simplify.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def subclause_reduction ( cnf_instance : cnf . Cnf ) -> cnf . Cnf : \"\"\"Replace the conjunction of two clauses with the smaller clause. If c\u2081 c\u2082 : cnf.Clause, we sat the c\u2081 \u226a c\u2082 if every literal of c\u2081 is in c\u2082. Replace c\u2081 \u2227 c\u2082 with c\u2081 whenever c\u2081 \u226a c\u2082. Perform action recursively. \"\"\" for clause1 , clause2 in it . permutations ( cnf_instance , 2 ): if clause1 <= clause2 : new_cnf : cnf . Cnf = cnf . cnf ( cnf_instance - { clause2 }) return subclause_reduction ( new_cnf ) return cnf_instance","title":"subclause_reduction()"},{"location":"index.md%20README/","text":"A Python package for working with Conjunctive Normal Form (CNFs) and Boolean Satisfiability (SAT) This Python package is brought to you by Vaibhav Karve and Anil N. Hirani , Department of Mathematics, University of Illinois at Urbana-Champaign. normal-form recognizes variables, literals, clauses, and CNFs. The package implements an interface to easily construct CNFs and SAT-check them via third-part libraries MINISAT and PySAT . This package is written in Python v3.10, and is publicly available under the GNU-GPL-v3.0 license . It is set to be released on the Python Packaging Index as an open-source scientific package written in the literate programming style. We specifically chose to write this package as a literate program, despite the verbosity of this style, with the goal to create reproducible computational research. Installation and usage To get started on using this package, Istall Python 3.10 or higher. python3.10 -m pip install normal-form Use it in a python script (or interactive REPL) as \u2013 from normal_form import cnf from normal_form import sat # This is the CNF (a \u2228 b \u2228 \u00acc) \u2227 (\u00acb \u2228 c \u2228 \u00acd) \u2227 (\u00aca \u2228 d). x1: cnf.Cnf = cnf.cnf([[1, 2, -3], [-2, 3, -4], [-1, 4]]) sat_x1: bool = sat.cnf_bruteforce_satcheck(x1) print(sat_x1) # prints: True because x1 is satisfiable. Overview of modules The package consists of the following modules. Modules that act on Cnfs cnf.py Constructors and functions for sentences in conjunctive normal form cnf_simplify.py Functions for simplifying Cnfs, for example (a\u2228b\u2228c) \u2227 (a\u2228b\u2228\u00ac c) \u21dd (a \u2228 b) prop.py Functions for propositional calculus \u2013 conjunction, disjunction and negation Modules concerning SAT sat.py Functions for sat-checking Cnfs sxpr.py Functions for working with s-expressions Test suite tests/* Unit- and property-based tests for each module Algorithms Currently, normal-form implements the following algorithms \u2013 For formulae in conjunctive normal forms (CNFs), it implements variables, literals, clauses, Boolean formulae, and truth-assignments. It includes an API for reading, parsing and defining new instances. For satisfiability of CNFs, it contains a bruteforce algorithm, an implementation that uses the open-source sat-solver PySAT , and an implementation using the MiniSAT solver. Principles normal-form has been written in the functional-programming style with the following principles in mind \u2013 Avoid classes as much as possible. Prefer defining functions instead. Write small functions and then compose/map/filter them to create more complex functions. Use lazy evaluation strategy whenever possible (using the itertools library). Add type hints wherever possible (checked using the mypy static type-checker). Add unit-tests for each function (checked using the pytest framework). Further, add property-based testing wherever possible (using the hypothesis framework).","title":"index.md README"},{"location":"index.md%20README/#installation-and-usage","text":"To get started on using this package, Istall Python 3.10 or higher. python3.10 -m pip install normal-form Use it in a python script (or interactive REPL) as \u2013 from normal_form import cnf from normal_form import sat # This is the CNF (a \u2228 b \u2228 \u00acc) \u2227 (\u00acb \u2228 c \u2228 \u00acd) \u2227 (\u00aca \u2228 d). x1: cnf.Cnf = cnf.cnf([[1, 2, -3], [-2, 3, -4], [-1, 4]]) sat_x1: bool = sat.cnf_bruteforce_satcheck(x1) print(sat_x1) # prints: True because x1 is satisfiable.","title":"Installation and usage"},{"location":"index.md%20README/#overview-of-modules","text":"The package consists of the following modules. Modules that act on Cnfs cnf.py Constructors and functions for sentences in conjunctive normal form cnf_simplify.py Functions for simplifying Cnfs, for example (a\u2228b\u2228c) \u2227 (a\u2228b\u2228\u00ac c) \u21dd (a \u2228 b) prop.py Functions for propositional calculus \u2013 conjunction, disjunction and negation Modules concerning SAT sat.py Functions for sat-checking Cnfs sxpr.py Functions for working with s-expressions Test suite tests/* Unit- and property-based tests for each module","title":"Overview of modules"},{"location":"index.md%20README/#algorithms","text":"Currently, normal-form implements the following algorithms \u2013 For formulae in conjunctive normal forms (CNFs), it implements variables, literals, clauses, Boolean formulae, and truth-assignments. It includes an API for reading, parsing and defining new instances. For satisfiability of CNFs, it contains a bruteforce algorithm, an implementation that uses the open-source sat-solver PySAT , and an implementation using the MiniSAT solver.","title":"Algorithms"},{"location":"index.md%20README/#principles","text":"normal-form has been written in the functional-programming style with the following principles in mind \u2013 Avoid classes as much as possible. Prefer defining functions instead. Write small functions and then compose/map/filter them to create more complex functions. Use lazy evaluation strategy whenever possible (using the itertools library). Add type hints wherever possible (checked using the mypy static type-checker). Add unit-tests for each function (checked using the pytest framework). Further, add property-based testing wherever possible (using the hypothesis framework).","title":"Principles"},{"location":"literate_documentation/","text":"Literate Documentation ... Under Construction ...","title":"..."},{"location":"literate_documentation/#literate-documentation","text":"... Under Construction ...","title":"Literate Documentation"},{"location":"prop/","text":"prop.py Functions for propositional calculus -- conjunction, disjunction and negation. clause_and_clause ( clause1 , clause2 ) Conjunction of a clause and a clause. Source code in normal_form/prop.py 24 25 26 def clause_and_clause ( clause1 : Clause , clause2 : Clause ) -> Cnf : \"\"\"Conjunction of a clause and a clause.\"\"\" return cnf ([ clause1 , clause2 ]) clause_and_literal ( clause_ , literal ) Conjunction of a clause and literal. Source code in normal_form/prop.py 19 20 21 def clause_and_literal ( clause_ : Clause , literal : Lit ) -> Cnf : \"\"\"Conjunction of a clause and literal.\"\"\" return cnf ([ clause_ , [ literal ]]) clause_or_clause ( clause1 , clause2 ) Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 58 59 60 def clause_or_clause ( clause1 : Clause , clause2 : Clause ) -> Clause : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return clause ( clause1 | clause2 ) clause_or_literal ( clause_ , literal ) Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 53 54 55 def clause_or_literal ( clause_ : Clause , literal : Lit ) -> Clause : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return clause ( clause_ | { literal }) cnf_and_clause ( cnf1 , clause_ ) Conjunction of a Cnf and a clause. Source code in normal_form/prop.py 34 35 36 def cnf_and_clause ( cnf1 : Cnf , clause_ : Clause ) -> Cnf : \"\"\"Conjunction of a Cnf and a clause.\"\"\" return cnf ( cnf1 | { clause_ }) cnf_and_cnf ( cnf1 , cnf2 ) Conjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 39 40 41 def cnf_and_cnf ( cnf1 : Cnf , cnf2 : Cnf ) -> Cnf : \"\"\"Conjunction of a Cnf and a Cnf.\"\"\" return cnf ( cnf1 | cnf2 ) cnf_and_literal ( cnf1 , literal ) Conjuncton of a Cnf and a literal. Source code in normal_form/prop.py 29 30 31 def cnf_and_literal ( cnf1 : Cnf , literal : Lit ) -> Cnf : \"\"\"Conjuncton of a Cnf and a literal.\"\"\" return cnf ( cnf1 | {( literal , )}) cnf_or_clause ( cnf1 , clause_ ) Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 68 69 70 def cnf_or_clause ( cnf1 : Cnf , clause_ : Clause ) -> Cnf : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return cnf ([ clause_or_clause ( clause1 , clause_ ) for clause1 in cnf1 ]) cnf_or_cnf ( cnf1 , cnf2 ) Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 73 74 75 def cnf_or_cnf ( cnf1 : Cnf , cnf2 : Cnf ) -> Cnf : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return ft . reduce ( cnf_and_cnf , ( cnf_or_clause ( cnf1 , clause ) for clause in cnf2 )) cnf_or_literal ( cnf1 , literal ) Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 63 64 65 def cnf_or_literal ( cnf1 : Cnf , literal : Lit ) -> Cnf : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return cnf ([ clause_or_literal ( clause , literal ) for clause in cnf1 ]) literal_and_literal ( literal1 , literal2 ) Conjunction of a literal and a literal. Source code in normal_form/prop.py 14 15 16 def literal_and_literal ( literal1 : Lit , literal2 : Lit ) -> Cnf : \"\"\"Conjunction of a literal and a literal.\"\"\" return cnf ([[ literal1 ], [ literal2 ]]) literal_or_literal ( literal1 , literal2 ) Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 48 49 50 def literal_or_literal ( literal1 : Lit , literal2 : Lit ) -> Clause : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return clause ([ literal1 , literal2 ]) neg_clause ( clause1 ) Negate a Clause by distributing negation across literals and returning resulting Cnf. Example negation of (a \u2228 b \u2228 \u00ac c) = \u00ac(a \u2228 b \u2228 \u00ac c) = (\u00ac a \u2227 \u00ac b \u2227 c) : Cnf. This function is an almost-involution in the sense that two negations return us back to the original clause, but we pass through an intermediate Cnf-instance. Source code in normal_form/prop.py 82 83 84 85 86 87 88 89 90 91 def neg_clause ( clause1 : Clause ) -> Cnf : \"\"\"Negate a Clause by distributing negation across literals and returning resulting Cnf. Example: negation of (a \u2228 b \u2228 \u00ac c) = \u00ac(a \u2228 b \u2228 \u00ac c) = (\u00ac a \u2227 \u00ac b \u2227 c) : Cnf. This function is an almost-involution in the sense that two negations return us back to the original clause, but we pass through an intermediate Cnf-instance. \"\"\" return cnf ( clause ([ neg ( literal )]) for literal in clause1 ) neg_cnf ( cnf1 ) Negate a Cnf by distributing negation across clauses and returning resulting Cnf. Example negation of (c\u2081 \u2227 c\u2082) = \u00ac(c\u2081 \u2227 c\u2082) = \u00acc\u2081 \u2228 \u00acc\u2082 : Cnf. This function is an involution. Source code in normal_form/prop.py 94 95 96 97 98 99 100 101 102 def neg_cnf ( cnf1 : Cnf ) -> Cnf : \"\"\"Negate a Cnf by distributing negation across clauses and returning resulting Cnf. Example: negation of (c\u2081 \u2227 c\u2082) = \u00ac(c\u2081 \u2227 c\u2082) = \u00acc\u2081 \u2228 \u00acc\u2082 : Cnf. This function is an involution. \"\"\" return ft . reduce ( cnf_or_cnf , map ( neg_clause , cnf1 ))","title":"prop.py"},{"location":"prop/#proppy","text":"Functions for propositional calculus -- conjunction, disjunction and negation.","title":"prop.py"},{"location":"prop/#normal_form.prop.clause_and_clause","text":"Conjunction of a clause and a clause. Source code in normal_form/prop.py 24 25 26 def clause_and_clause ( clause1 : Clause , clause2 : Clause ) -> Cnf : \"\"\"Conjunction of a clause and a clause.\"\"\" return cnf ([ clause1 , clause2 ])","title":"clause_and_clause()"},{"location":"prop/#normal_form.prop.clause_and_literal","text":"Conjunction of a clause and literal. Source code in normal_form/prop.py 19 20 21 def clause_and_literal ( clause_ : Clause , literal : Lit ) -> Cnf : \"\"\"Conjunction of a clause and literal.\"\"\" return cnf ([ clause_ , [ literal ]])","title":"clause_and_literal()"},{"location":"prop/#normal_form.prop.clause_or_clause","text":"Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 58 59 60 def clause_or_clause ( clause1 : Clause , clause2 : Clause ) -> Clause : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return clause ( clause1 | clause2 )","title":"clause_or_clause()"},{"location":"prop/#normal_form.prop.clause_or_literal","text":"Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 53 54 55 def clause_or_literal ( clause_ : Clause , literal : Lit ) -> Clause : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return clause ( clause_ | { literal })","title":"clause_or_literal()"},{"location":"prop/#normal_form.prop.cnf_and_clause","text":"Conjunction of a Cnf and a clause. Source code in normal_form/prop.py 34 35 36 def cnf_and_clause ( cnf1 : Cnf , clause_ : Clause ) -> Cnf : \"\"\"Conjunction of a Cnf and a clause.\"\"\" return cnf ( cnf1 | { clause_ })","title":"cnf_and_clause()"},{"location":"prop/#normal_form.prop.cnf_and_cnf","text":"Conjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 39 40 41 def cnf_and_cnf ( cnf1 : Cnf , cnf2 : Cnf ) -> Cnf : \"\"\"Conjunction of a Cnf and a Cnf.\"\"\" return cnf ( cnf1 | cnf2 )","title":"cnf_and_cnf()"},{"location":"prop/#normal_form.prop.cnf_and_literal","text":"Conjuncton of a Cnf and a literal. Source code in normal_form/prop.py 29 30 31 def cnf_and_literal ( cnf1 : Cnf , literal : Lit ) -> Cnf : \"\"\"Conjuncton of a Cnf and a literal.\"\"\" return cnf ( cnf1 | {( literal , )})","title":"cnf_and_literal()"},{"location":"prop/#normal_form.prop.cnf_or_clause","text":"Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 68 69 70 def cnf_or_clause ( cnf1 : Cnf , clause_ : Clause ) -> Cnf : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return cnf ([ clause_or_clause ( clause1 , clause_ ) for clause1 in cnf1 ])","title":"cnf_or_clause()"},{"location":"prop/#normal_form.prop.cnf_or_cnf","text":"Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 73 74 75 def cnf_or_cnf ( cnf1 : Cnf , cnf2 : Cnf ) -> Cnf : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return ft . reduce ( cnf_and_cnf , ( cnf_or_clause ( cnf1 , clause ) for clause in cnf2 ))","title":"cnf_or_cnf()"},{"location":"prop/#normal_form.prop.cnf_or_literal","text":"Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 63 64 65 def cnf_or_literal ( cnf1 : Cnf , literal : Lit ) -> Cnf : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return cnf ([ clause_or_literal ( clause , literal ) for clause in cnf1 ])","title":"cnf_or_literal()"},{"location":"prop/#normal_form.prop.literal_and_literal","text":"Conjunction of a literal and a literal. Source code in normal_form/prop.py 14 15 16 def literal_and_literal ( literal1 : Lit , literal2 : Lit ) -> Cnf : \"\"\"Conjunction of a literal and a literal.\"\"\" return cnf ([[ literal1 ], [ literal2 ]])","title":"literal_and_literal()"},{"location":"prop/#normal_form.prop.literal_or_literal","text":"Disjunction of a Cnf and a Cnf. Source code in normal_form/prop.py 48 49 50 def literal_or_literal ( literal1 : Lit , literal2 : Lit ) -> Clause : \"\"\"Disjunction of a Cnf and a Cnf.\"\"\" return clause ([ literal1 , literal2 ])","title":"literal_or_literal()"},{"location":"prop/#normal_form.prop.neg_clause","text":"Negate a Clause by distributing negation across literals and returning resulting Cnf. Example negation of (a \u2228 b \u2228 \u00ac c) = \u00ac(a \u2228 b \u2228 \u00ac c) = (\u00ac a \u2227 \u00ac b \u2227 c) : Cnf. This function is an almost-involution in the sense that two negations return us back to the original clause, but we pass through an intermediate Cnf-instance. Source code in normal_form/prop.py 82 83 84 85 86 87 88 89 90 91 def neg_clause ( clause1 : Clause ) -> Cnf : \"\"\"Negate a Clause by distributing negation across literals and returning resulting Cnf. Example: negation of (a \u2228 b \u2228 \u00ac c) = \u00ac(a \u2228 b \u2228 \u00ac c) = (\u00ac a \u2227 \u00ac b \u2227 c) : Cnf. This function is an almost-involution in the sense that two negations return us back to the original clause, but we pass through an intermediate Cnf-instance. \"\"\" return cnf ( clause ([ neg ( literal )]) for literal in clause1 )","title":"neg_clause()"},{"location":"prop/#normal_form.prop.neg_cnf","text":"Negate a Cnf by distributing negation across clauses and returning resulting Cnf. Example negation of (c\u2081 \u2227 c\u2082) = \u00ac(c\u2081 \u2227 c\u2082) = \u00acc\u2081 \u2228 \u00acc\u2082 : Cnf. This function is an involution. Source code in normal_form/prop.py 94 95 96 97 98 99 100 101 102 def neg_cnf ( cnf1 : Cnf ) -> Cnf : \"\"\"Negate a Cnf by distributing negation across clauses and returning resulting Cnf. Example: negation of (c\u2081 \u2227 c\u2082) = \u00ac(c\u2081 \u2227 c\u2082) = \u00acc\u2081 \u2228 \u00acc\u2082 : Cnf. This function is an involution. \"\"\" return ft . reduce ( cnf_or_cnf , map ( neg_clause , cnf1 ))","title":"neg_cnf()"},{"location":"sat/","text":"sat.py Functions for sat-checking Cnfs, Graphs, and MHGraphs. Satisfiability of Cnfs A Cnf is satisfiable if there exists a truth assignment for each variable in the Cnf such that on applying the assignment, the Cnf evaluates to True. This module implements three different sat-solvers cnf_bruteforce_satcheck: a brute-force solver. This solver is easy to understand and reason about. It does not have other external dependencies. However, it is quite slow. cnf_pysat_satcheck: using the pysat library's Minisat22 solver. This solver calls Minisat v2.2 via the pysat library. It is the fast solver in this list but has many external dependencies (because pysat has many dependencies). cnf_minisat_satcheck: using Minisat v2.2 as a subprocess. This calls minisat.c directly as a subprocess. minisat.c is easy to obtain and install. However, creating subprocesses is not a very fast process. TODO: Add a function for equisatisfiability of Cnfs cnf_bruteforce_satcheck ( cnf_instance ) Use brute force to check satisfiability of Cnf. .. note:: Brute-forcing is the most sub-optimal strategy possible. Do not use this function on large Cnfs. (Anything more than 6 Variables or 6 Clauses is large.) Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return First, tautologically reduce the Cnf. Then. if the Cnf is Satisfiable return True else return False . Source code in normal_form/sat.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def cnf_bruteforce_satcheck ( cnf_instance : Cnf ) -> bool : \"\"\"Use brute force to check satisfiability of Cnf. .. note:: Brute-forcing is the most sub-optimal strategy possible. Do not use this function on large Cnfs. (Anything more than 6 Variables or 6 Clauses is large.) Args: cnf_instance (:obj:`Cnf`) Return: First, tautologically reduce the Cnf. Then. if the Cnf is Satisfiable return ``True`` else return ``False``. \"\"\" cnf_reduced : Cnf = tauto_reduce ( cnf_instance ) if cnf_reduced == TRUE_CNF : return True if cnf_reduced == FALSE_CNF : return False def assigns_cnf_to_true ( assignment : Assignment ) -> bool : return assign ( cnf_reduced , assignment ) == TRUE_CNF # Note: cnf_reduced cannot be TRUE/FALSE, hence all_assignments != ({}) head : list [ Assignment ] all_assignments : Iterator [ Assignment ] = generate_assignments ( cnf_reduced ) head , all_assignments = mit . spy ( all_assignments ) assert head != [{}], \"Empty assignment generated.\" satisfying_assignments : Iterator [ Assignment ] satisfying_assignments = filter ( assigns_cnf_to_true , all_assignments ) return any ( satisfying_assignments ) cnf_minisat_satcheck ( cnf_instance ) Use the subprocess library to call minisat.c solver to sat-check a Cnf. minisat.c should be correctly installed for this to work. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return If the Cnf is Satisfiable return True else return False . Source code in normal_form/sat.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def cnf_minisat_satcheck ( cnf_instance : Cnf ) -> bool : \"\"\"Use the `subprocess` library to call minisat.c solver to sat-check a Cnf. minisat.c should be correctly installed for this to work. Args: cnf_instance (:obj:`Cnf`) Return: If the Cnf is Satisfiable return ``True`` else return ``False``. \"\"\" cnf_dimacs : str cnf_dimacs = cnf_to_dimacs ( cnf_instance ) output : str = subprocess . run ([ 'minisat' , '-rnd-init' , '-verb=0' ], input = cnf_dimacs , text = True , capture_output = True , shell = True , check = False ) . stdout assert output , \"Empty output. Check if minisat is installed on your system.\" result : str = output . split ()[ - 1 ] if result == 'SATISFIABLE' : return True if result == 'UNSATISFIABLE' : return False raise RuntimeError ( 'Unexpected output from minisat.' , output ) # pragma: no cover cnf_pysat_satcheck ( cnf_instance ) Use the pysat library's Minisat22 solver to sat-check a Cnf. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return If the Cnf is Satisfiable return True else return False . Source code in normal_form/sat.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def cnf_pysat_satcheck ( cnf_instance : Cnf ) -> bool : \"\"\"Use the `pysat` library's Minisat22 solver to sat-check a Cnf. Args: cnf_instance (:obj:`Cnf`) Return: If the Cnf is Satisfiable return ``True`` else return ``False``. \"\"\" if cnf_instance == TRUE_CNF : return True if cnf_instance == FALSE_CNF : return False try : if ( result := Minisat22 ( int_repr ( cnf_instance )) . solve ()) is None : raise RuntimeError ( \"Minisat22 returned None as result.\" ) # pragma: nocover return result except ( TypeError , RuntimeError ) as exc : # The Cnf was probably not in reduced form. Reduce and try again cnf_reduced : Cnf = tauto_reduce ( cnf_instance ) if cnf_reduced == cnf_instance : raise RuntimeError ( \"Irreducible Cnf not getting solved by Minisat22\" ) from exc # pragma: nocover return cnf_pysat_satcheck ( cnf_instance = cnf_reduced ) cnf_to_dimacs ( cnf_instance ) Convert a Cnf to DIMACS format. The Cnf is tautologically reduced first so as to not contain TRUE or FALSE lits. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return A string which consists of lines. Each line is a Clause of the Cnf ending with zero. Each lit in the Clause is written with a space delimiter. After tautological reduction, if the Cnf reduced to TRUE or FALSE then return a string that will be correctly interpreted as such. Source code in normal_form/sat.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def cnf_to_dimacs ( cnf_instance : Cnf ) -> str : \"\"\"Convert a Cnf to DIMACS format. The Cnf is tautologically reduced first so as to not contain TRUE or FALSE lits. Args: cnf_instance (:obj:`Cnf`) Return: A string which consists of lines. Each line is a Clause of the Cnf ending with zero. Each lit in the Clause is written with a space delimiter. After tautological reduction, if the Cnf reduced to TRUE or FALSE then return a string that will be correctly interpreted as such. \"\"\" cnf_reduced : Cnf cnf_reduced = tauto_reduce ( cnf_instance ) if cnf_reduced == TRUE_CNF : return '' # A Clause that is always satisfied if cnf_reduced == FALSE_CNF : return '0' # A Clause that can never be satisfied clause_strs : map [ map [ str ]] clause_strs = map ( lambda clause : map ( str , clause ), int_repr ( cnf_reduced )) clause_strs_with_tails : map [ str ] clause_strs_with_tails = map ( lambda clause_str : ' ' . join ( clause_str ) + ' 0' , clause_strs ) return ' \\n ' . join ( clause_strs_with_tails ) generate_assignments ( cnf_instance ) Generate all :math: 2^n truth-assignments for a Cnf with :math: n Variables. A Cnf's truth-assignment will be represented as a dictionary with keys being all the Variables that appear in the Cnf and values being Bools. Edge cases TRUE / FALSE Cnfs are treated as having :math: 0 Variables and therefore their only corresponding truth-assignment is the empty dictionary. In other words, the function returns ({}) . Any Cnf that can be tautologically reduced to TRUE/FALSE also returns ({}) . This function cannot distinguish between sat/unsat Cnfs. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return First, tautologically reduce the Cnf. Then, return an Iterator of truth-assignment dictionaries with keys being Variables and values being Bools. Source code in normal_form/sat.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def generate_assignments ( cnf_instance : Cnf ) -> Iterator [ Assignment ]: \"\"\"Generate all :math:`2^n` truth-assignments for a Cnf with :math:`n` Variables. A Cnf's `truth-assignment` will be represented as a dictionary with keys being all the Variables that appear in the Cnf and values being Bools. Edge cases: * ``TRUE``/``FALSE`` Cnfs are treated as having :math:`0` Variables and therefore their only corresponding truth-assignment is the empty dictionary. In other words, the function returns ``({})``. * Any Cnf that can be tautologically reduced to TRUE/FALSE also returns ``({})``. * This function cannot distinguish between sat/unsat Cnfs. Args: cnf_instance (:obj:`Cnf`) Return: First, tautologically reduce the Cnf. Then, return an Iterator of truth-assignment dictionaries with keys being Variables and values being Bools. \"\"\" cnf_reduced : Cnf cnf_reduced = tauto_reduce ( cnf_instance ) lit_set : frozenset [ Lit ] lit_set = lits ( cnf_reduced ) - { lit ( Bool . TRUE ), lit ( Bool . FALSE )} lit_value_set : set [ int | Bool ] = { absolute_value ( literal ) . value for literal in lit_set } assert all ( isinstance ( value , int ) for value in lit_value_set ) variable_set : set [ Variable ] variable_set = { variable ( cast ( int , value )) for value in lit_value_set } assignment_values : Iterator [ tuple [ Bool , ... ]] assignment_values = it . product ([ Bool . TRUE , Bool . FALSE ], repeat = len ( variable_set )) for boolean_tuple in assignment_values : yield dict ( zip ( variable_set , boolean_tuple ))","title":"sat.py"},{"location":"sat/#satpy","text":"Functions for sat-checking Cnfs, Graphs, and MHGraphs.","title":"sat.py"},{"location":"sat/#normal_form.sat--satisfiability-of-cnfs","text":"A Cnf is satisfiable if there exists a truth assignment for each variable in the Cnf such that on applying the assignment, the Cnf evaluates to True. This module implements three different sat-solvers cnf_bruteforce_satcheck: a brute-force solver. This solver is easy to understand and reason about. It does not have other external dependencies. However, it is quite slow. cnf_pysat_satcheck: using the pysat library's Minisat22 solver. This solver calls Minisat v2.2 via the pysat library. It is the fast solver in this list but has many external dependencies (because pysat has many dependencies). cnf_minisat_satcheck: using Minisat v2.2 as a subprocess. This calls minisat.c directly as a subprocess. minisat.c is easy to obtain and install. However, creating subprocesses is not a very fast process. TODO: Add a function for equisatisfiability of Cnfs","title":"Satisfiability of Cnfs"},{"location":"sat/#normal_form.sat.cnf_bruteforce_satcheck","text":"Use brute force to check satisfiability of Cnf. .. note:: Brute-forcing is the most sub-optimal strategy possible. Do not use this function on large Cnfs. (Anything more than 6 Variables or 6 Clauses is large.) Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return First, tautologically reduce the Cnf. Then. if the Cnf is Satisfiable return True else return False . Source code in normal_form/sat.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def cnf_bruteforce_satcheck ( cnf_instance : Cnf ) -> bool : \"\"\"Use brute force to check satisfiability of Cnf. .. note:: Brute-forcing is the most sub-optimal strategy possible. Do not use this function on large Cnfs. (Anything more than 6 Variables or 6 Clauses is large.) Args: cnf_instance (:obj:`Cnf`) Return: First, tautologically reduce the Cnf. Then. if the Cnf is Satisfiable return ``True`` else return ``False``. \"\"\" cnf_reduced : Cnf = tauto_reduce ( cnf_instance ) if cnf_reduced == TRUE_CNF : return True if cnf_reduced == FALSE_CNF : return False def assigns_cnf_to_true ( assignment : Assignment ) -> bool : return assign ( cnf_reduced , assignment ) == TRUE_CNF # Note: cnf_reduced cannot be TRUE/FALSE, hence all_assignments != ({}) head : list [ Assignment ] all_assignments : Iterator [ Assignment ] = generate_assignments ( cnf_reduced ) head , all_assignments = mit . spy ( all_assignments ) assert head != [{}], \"Empty assignment generated.\" satisfying_assignments : Iterator [ Assignment ] satisfying_assignments = filter ( assigns_cnf_to_true , all_assignments ) return any ( satisfying_assignments )","title":"cnf_bruteforce_satcheck()"},{"location":"sat/#normal_form.sat.cnf_minisat_satcheck","text":"Use the subprocess library to call minisat.c solver to sat-check a Cnf. minisat.c should be correctly installed for this to work. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return If the Cnf is Satisfiable return True else return False . Source code in normal_form/sat.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def cnf_minisat_satcheck ( cnf_instance : Cnf ) -> bool : \"\"\"Use the `subprocess` library to call minisat.c solver to sat-check a Cnf. minisat.c should be correctly installed for this to work. Args: cnf_instance (:obj:`Cnf`) Return: If the Cnf is Satisfiable return ``True`` else return ``False``. \"\"\" cnf_dimacs : str cnf_dimacs = cnf_to_dimacs ( cnf_instance ) output : str = subprocess . run ([ 'minisat' , '-rnd-init' , '-verb=0' ], input = cnf_dimacs , text = True , capture_output = True , shell = True , check = False ) . stdout assert output , \"Empty output. Check if minisat is installed on your system.\" result : str = output . split ()[ - 1 ] if result == 'SATISFIABLE' : return True if result == 'UNSATISFIABLE' : return False raise RuntimeError ( 'Unexpected output from minisat.' , output ) # pragma: no cover","title":"cnf_minisat_satcheck()"},{"location":"sat/#normal_form.sat.cnf_pysat_satcheck","text":"Use the pysat library's Minisat22 solver to sat-check a Cnf. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return If the Cnf is Satisfiable return True else return False . Source code in normal_form/sat.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def cnf_pysat_satcheck ( cnf_instance : Cnf ) -> bool : \"\"\"Use the `pysat` library's Minisat22 solver to sat-check a Cnf. Args: cnf_instance (:obj:`Cnf`) Return: If the Cnf is Satisfiable return ``True`` else return ``False``. \"\"\" if cnf_instance == TRUE_CNF : return True if cnf_instance == FALSE_CNF : return False try : if ( result := Minisat22 ( int_repr ( cnf_instance )) . solve ()) is None : raise RuntimeError ( \"Minisat22 returned None as result.\" ) # pragma: nocover return result except ( TypeError , RuntimeError ) as exc : # The Cnf was probably not in reduced form. Reduce and try again cnf_reduced : Cnf = tauto_reduce ( cnf_instance ) if cnf_reduced == cnf_instance : raise RuntimeError ( \"Irreducible Cnf not getting solved by Minisat22\" ) from exc # pragma: nocover return cnf_pysat_satcheck ( cnf_instance = cnf_reduced )","title":"cnf_pysat_satcheck()"},{"location":"sat/#normal_form.sat.cnf_to_dimacs","text":"Convert a Cnf to DIMACS format. The Cnf is tautologically reduced first so as to not contain TRUE or FALSE lits. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return A string which consists of lines. Each line is a Clause of the Cnf ending with zero. Each lit in the Clause is written with a space delimiter. After tautological reduction, if the Cnf reduced to TRUE or FALSE then return a string that will be correctly interpreted as such. Source code in normal_form/sat.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def cnf_to_dimacs ( cnf_instance : Cnf ) -> str : \"\"\"Convert a Cnf to DIMACS format. The Cnf is tautologically reduced first so as to not contain TRUE or FALSE lits. Args: cnf_instance (:obj:`Cnf`) Return: A string which consists of lines. Each line is a Clause of the Cnf ending with zero. Each lit in the Clause is written with a space delimiter. After tautological reduction, if the Cnf reduced to TRUE or FALSE then return a string that will be correctly interpreted as such. \"\"\" cnf_reduced : Cnf cnf_reduced = tauto_reduce ( cnf_instance ) if cnf_reduced == TRUE_CNF : return '' # A Clause that is always satisfied if cnf_reduced == FALSE_CNF : return '0' # A Clause that can never be satisfied clause_strs : map [ map [ str ]] clause_strs = map ( lambda clause : map ( str , clause ), int_repr ( cnf_reduced )) clause_strs_with_tails : map [ str ] clause_strs_with_tails = map ( lambda clause_str : ' ' . join ( clause_str ) + ' 0' , clause_strs ) return ' \\n ' . join ( clause_strs_with_tails )","title":"cnf_to_dimacs()"},{"location":"sat/#normal_form.sat.generate_assignments","text":"Generate all :math: 2^n truth-assignments for a Cnf with :math: n Variables. A Cnf's truth-assignment will be represented as a dictionary with keys being all the Variables that appear in the Cnf and values being Bools. Edge cases TRUE / FALSE Cnfs are treated as having :math: 0 Variables and therefore their only corresponding truth-assignment is the empty dictionary. In other words, the function returns ({}) . Any Cnf that can be tautologically reduced to TRUE/FALSE also returns ({}) . This function cannot distinguish between sat/unsat Cnfs. Parameters: Name Type Description Default cnf_instance obj: Cnf ) required Return First, tautologically reduce the Cnf. Then, return an Iterator of truth-assignment dictionaries with keys being Variables and values being Bools. Source code in normal_form/sat.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def generate_assignments ( cnf_instance : Cnf ) -> Iterator [ Assignment ]: \"\"\"Generate all :math:`2^n` truth-assignments for a Cnf with :math:`n` Variables. A Cnf's `truth-assignment` will be represented as a dictionary with keys being all the Variables that appear in the Cnf and values being Bools. Edge cases: * ``TRUE``/``FALSE`` Cnfs are treated as having :math:`0` Variables and therefore their only corresponding truth-assignment is the empty dictionary. In other words, the function returns ``({})``. * Any Cnf that can be tautologically reduced to TRUE/FALSE also returns ``({})``. * This function cannot distinguish between sat/unsat Cnfs. Args: cnf_instance (:obj:`Cnf`) Return: First, tautologically reduce the Cnf. Then, return an Iterator of truth-assignment dictionaries with keys being Variables and values being Bools. \"\"\" cnf_reduced : Cnf cnf_reduced = tauto_reduce ( cnf_instance ) lit_set : frozenset [ Lit ] lit_set = lits ( cnf_reduced ) - { lit ( Bool . TRUE ), lit ( Bool . FALSE )} lit_value_set : set [ int | Bool ] = { absolute_value ( literal ) . value for literal in lit_set } assert all ( isinstance ( value , int ) for value in lit_value_set ) variable_set : set [ Variable ] variable_set = { variable ( cast ( int , value )) for value in lit_value_set } assignment_values : Iterator [ tuple [ Bool , ... ]] assignment_values = it . product ([ Bool . TRUE , Bool . FALSE ], repeat = len ( variable_set )) for boolean_tuple in assignment_values : yield dict ( zip ( variable_set , boolean_tuple ))","title":"generate_assignments()"},{"location":"sxpr/","text":"sxpr.py Functions for working with s-expressions. s-expressions are inspired from ELisp. SatSxpr Bases: Sxpr [ Src , bool ] A subclass of Sxpr[--, bool]. Parameters: Name Type Description Default op obj: Callable[[bool, Src], bool] ): This can only be one of two options -- either sat_and or sat_or . required terms obj: Tuple[Src, ...] ): a tuple of terms. required Returns: Type Description Computes init value based on op . Then calls the __init__ method of Sxpr . Source code in normal_form/sxpr.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class SatSxpr ( Sxpr [ Src , bool ]): # pylint: disable=too-few-public-methods \"\"\"A subclass of Sxpr[--, bool]. Args: op (:obj:`Callable[[bool, Src], bool]`): This can only be one of two options -- either `sat_and` or `sat_or`. terms (:obj:`Tuple[Src, ...]`): a tuple of terms. Returns: Computes `init` value based on `op`. Then calls the `__init__` method of `Sxpr`. \"\"\" def __init__ ( self , op : Callable [[ bool , Src ], bool ], terms : Tuple [ Src , ... ]): init : bool if op . __name__ in ( 'sat_and' , 'and_' ): init = True elif op . __name__ in ( 'sat_or' , 'or_' ): init = False else : raise ValueError ( f 'Unknown operation { op . __name__ = } encountered' ) super () . __init__ ( op , terms , init ) def __repr__ ( self ) -> str : # pragma: no cover \"\"\"Use for pretty-printing an S-expression.\"\"\" if self . op . __name__ in ( 'sat_and' , 'and' ): symb : str = ' \u2227 ' color : str = Fore . RED elif self . op . __name__ in ( 'sat_or' , 'or' ): symb = ' \u2228 ' color = Fore . GREEN else : symb = ' ? ' color = '' logger . warning ( f 'Unknown operation { self . op . __name__ = } encountered' ) reset : str = Style . RESET_ALL colored_symbol : str = color + symb + reset bracket : Tuple [ str , str ] = ( color + \"[\" + reset , color + \"]\" + reset ) if not self . terms : return bracket [ 0 ] + colored_symbol . join ( map ( repr , [ self . init ])) + bracket [ 1 ] return bracket [ 0 ] + colored_symbol . join ( map ( repr , self . terms )) + bracket [ 1 ] __repr__ () Use for pretty-printing an S-expression. Source code in normal_form/sxpr.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __repr__ ( self ) -> str : # pragma: no cover \"\"\"Use for pretty-printing an S-expression.\"\"\" if self . op . __name__ in ( 'sat_and' , 'and' ): symb : str = ' \u2227 ' color : str = Fore . RED elif self . op . __name__ in ( 'sat_or' , 'or' ): symb = ' \u2228 ' color = Fore . GREEN else : symb = ' ? ' color = '' logger . warning ( f 'Unknown operation { self . op . __name__ = } encountered' ) reset : str = Style . RESET_ALL colored_symbol : str = color + symb + reset bracket : Tuple [ str , str ] = ( color + \"[\" + reset , color + \"]\" + reset ) if not self . terms : return bracket [ 0 ] + colored_symbol . join ( map ( repr , [ self . init ])) + bracket [ 1 ] return bracket [ 0 ] + colored_symbol . join ( map ( repr , self . terms )) + bracket [ 1 ] Sxpr dataclass Bases: Generic [ Src , Trgt ] Define generic S-expression. Source code in normal_form/sxpr.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @dataclass class Sxpr ( Generic [ Src , Trgt ]): \"\"\"Define generic S-expression.\"\"\" op : Callable [[ Trgt , Src ], Trgt ] # pylint: disable=invalid-name terms : Tuple [ Src , ... ] init : Trgt def reduce ( self ) -> Trgt : \"\"\"Use ft.reduce to evaluate the s-expression. Example: (+, (1 2 3 4), 0) will evaluate to ((((0 + 1) + 2) + 3) + 4). \"\"\" return ft . reduce ( self . op , self . terms , self . init ) reduce () Use ft.reduce to evaluate the s-expression. Example (+, (1 2 3 4), 0) will evaluate to ((((0 + 1) + 2) + 3) + 4). Source code in normal_form/sxpr.py 28 29 30 31 32 33 34 def reduce ( self ) -> Trgt : \"\"\"Use ft.reduce to evaluate the s-expression. Example: (+, (1 2 3 4), 0) will evaluate to ((((0 + 1) + 2) + 3) + 4). \"\"\" return ft . reduce ( self . op , self . terms , self . init )","title":"sxpr.py"},{"location":"sxpr/#sxprpy","text":"Functions for working with s-expressions. s-expressions are inspired from ELisp.","title":"sxpr.py"},{"location":"sxpr/#normal_form.sxpr.SatSxpr","text":"Bases: Sxpr [ Src , bool ] A subclass of Sxpr[--, bool]. Parameters: Name Type Description Default op obj: Callable[[bool, Src], bool] ): This can only be one of two options -- either sat_and or sat_or . required terms obj: Tuple[Src, ...] ): a tuple of terms. required Returns: Type Description Computes init value based on op . Then calls the __init__ method of Sxpr . Source code in normal_form/sxpr.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class SatSxpr ( Sxpr [ Src , bool ]): # pylint: disable=too-few-public-methods \"\"\"A subclass of Sxpr[--, bool]. Args: op (:obj:`Callable[[bool, Src], bool]`): This can only be one of two options -- either `sat_and` or `sat_or`. terms (:obj:`Tuple[Src, ...]`): a tuple of terms. Returns: Computes `init` value based on `op`. Then calls the `__init__` method of `Sxpr`. \"\"\" def __init__ ( self , op : Callable [[ bool , Src ], bool ], terms : Tuple [ Src , ... ]): init : bool if op . __name__ in ( 'sat_and' , 'and_' ): init = True elif op . __name__ in ( 'sat_or' , 'or_' ): init = False else : raise ValueError ( f 'Unknown operation { op . __name__ = } encountered' ) super () . __init__ ( op , terms , init ) def __repr__ ( self ) -> str : # pragma: no cover \"\"\"Use for pretty-printing an S-expression.\"\"\" if self . op . __name__ in ( 'sat_and' , 'and' ): symb : str = ' \u2227 ' color : str = Fore . RED elif self . op . __name__ in ( 'sat_or' , 'or' ): symb = ' \u2228 ' color = Fore . GREEN else : symb = ' ? ' color = '' logger . warning ( f 'Unknown operation { self . op . __name__ = } encountered' ) reset : str = Style . RESET_ALL colored_symbol : str = color + symb + reset bracket : Tuple [ str , str ] = ( color + \"[\" + reset , color + \"]\" + reset ) if not self . terms : return bracket [ 0 ] + colored_symbol . join ( map ( repr , [ self . init ])) + bracket [ 1 ] return bracket [ 0 ] + colored_symbol . join ( map ( repr , self . terms )) + bracket [ 1 ]","title":"SatSxpr"},{"location":"sxpr/#normal_form.sxpr.SatSxpr.__repr__","text":"Use for pretty-printing an S-expression. Source code in normal_form/sxpr.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __repr__ ( self ) -> str : # pragma: no cover \"\"\"Use for pretty-printing an S-expression.\"\"\" if self . op . __name__ in ( 'sat_and' , 'and' ): symb : str = ' \u2227 ' color : str = Fore . RED elif self . op . __name__ in ( 'sat_or' , 'or' ): symb = ' \u2228 ' color = Fore . GREEN else : symb = ' ? ' color = '' logger . warning ( f 'Unknown operation { self . op . __name__ = } encountered' ) reset : str = Style . RESET_ALL colored_symbol : str = color + symb + reset bracket : Tuple [ str , str ] = ( color + \"[\" + reset , color + \"]\" + reset ) if not self . terms : return bracket [ 0 ] + colored_symbol . join ( map ( repr , [ self . init ])) + bracket [ 1 ] return bracket [ 0 ] + colored_symbol . join ( map ( repr , self . terms )) + bracket [ 1 ]","title":"__repr__()"},{"location":"sxpr/#normal_form.sxpr.Sxpr","text":"Bases: Generic [ Src , Trgt ] Define generic S-expression. Source code in normal_form/sxpr.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @dataclass class Sxpr ( Generic [ Src , Trgt ]): \"\"\"Define generic S-expression.\"\"\" op : Callable [[ Trgt , Src ], Trgt ] # pylint: disable=invalid-name terms : Tuple [ Src , ... ] init : Trgt def reduce ( self ) -> Trgt : \"\"\"Use ft.reduce to evaluate the s-expression. Example: (+, (1 2 3 4), 0) will evaluate to ((((0 + 1) + 2) + 3) + 4). \"\"\" return ft . reduce ( self . op , self . terms , self . init )","title":"Sxpr"},{"location":"sxpr/#normal_form.sxpr.Sxpr.reduce","text":"Use ft.reduce to evaluate the s-expression. Example (+, (1 2 3 4), 0) will evaluate to ((((0 + 1) + 2) + 3) + 4). Source code in normal_form/sxpr.py 28 29 30 31 32 33 34 def reduce ( self ) -> Trgt : \"\"\"Use ft.reduce to evaluate the s-expression. Example: (+, (1 2 3 4), 0) will evaluate to ((((0 + 1) + 2) + 3) + 4). \"\"\" return ft . reduce ( self . op , self . terms , self . init )","title":"reduce()"}]}